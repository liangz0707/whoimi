# Partial_Derivatives(DDX)原理与设备实现差异

## DDX\DDY的硬件条件

​	“导数”意思是在某一点上“函数的变化”。在图形处理当中，指的是相邻像素之间的变化。

​	ddx和ddy是常用的简单的图像导数，它们比较相邻的两个像素的垂直或水平值。具体的实现方法以及**结果**依赖于GPU的特殊架构结构细节。

​	在图形计算过程中，像素着色阶段的最小调度单元是一个warp，一个warp执行同一段程序，包括了最少32个线程。但是最小的执行单元是一个quad。也就是说一次最少需要执行一个2 * 2的像素，而不需要的像素会被丢弃掉。

​	这4个像素也就对应了四个线程，他们共同申请使用设备上下文，也就是说可以在硬件上，方便的访问到隔壁像素的数据。

​	根据硬件这一特性，我们可以利用ddx、ddy获取到更多的信息。

## DDX\DDY的使用方式

​	我们通过DDX和DDY可以访问当前像素的导数。

​	**注意，DDY和DDX返回的是屏幕像素的导数，因为计算的依据是屏幕像素的2 * 2的Block。**

​	具体的实现方式就是通过2 * 2 quad中的上（或下）、右（或左）相邻像素计算差值，获取到导数。

1.  通常我们可以用导数计算法线：

```c
void surf (Input IN, inout SurfaceOutput o) {
    o.Albedo = normalize(cross(ddy(IN.worldPos),ddx(IN.worldPos)));
}
```

2.通过导数我们也可以判断边缘，用来模糊或者锐化边界：

```c
void surf (Input IN, inout SurfaceOutput o) {
    half4 c = tex2D(_MainTex, IN.uv_MainTex);
    //c += ddx(c)*2 + ddy(c)*2; //这行代码开启和关闭的效果
    o.Albedo = c.rgb;
    o.Alpha = c.a;
}
```



## DDX\DDY的硬件差异

​	在上面的两个案例当中，通常我们是看不出任何差异的，因为我们使用的仅仅是**导数本身**。

​	并且当图像的变化比较平缓的时候（最大变化频率小于一个像素）。导数值可以代表周围一小个区域的导数（微积分的基础理论），此时看不出硬件和驱动的差异，但是在一些特殊的案例中就需要考虑硬件区别了。

​	对于一个屏幕上2 * 2的quad而言：

![image-20201123160345783](Partial_Derivatives(DDX)原理与设备实现差异/image-20201123160345783.png)

​	判断屏幕某个像素位置(x,y)所处的quad像素位置（A?B?C?D?）,可以使用下面代码：

```c
INDEX CheckQuadPos(int x, int y)
{
	if(x % 2 == 0 && y % 2 == 0)
    {
        return A;
    }
    else
    if(x % 2 == 1 && y % 2 == 0)
    {
        return B;
    }
    ...
}
```

​	如果当前线程处在A则DDX、DDY返回的一定是:

```c
TYPE DDX(TYPE value)
{
    return B - A;
}

TYPE DDY(TYPE value)
{
    return C - A;
}
```

​	通常可以假设：B-A可以代表周围几个像素的x方向的导数，包括位置C和位置D的x方向的倒数。所以通常对于一个quad中，驱动只需要计算B-A的值就可以知道整个quad的x方向偏导数。

​	但是如果我们想知道D-C怎么办？**返回的值和具体的图像API有关、不同的供应商对这个函数接口的实现可能也会有所差异。**

以下是实验结果：

对于ddx(C):

​	**在DX11上返回的是B-A，但是在openglES3、vulkan上，返回的是D-C。也就是说DX11可能对导数的实现进行了省略。**

对于ddy(D)

​	**在DX11上返回的是C-A，在OpenglES3、vulkan上，返回的是D-B。**

在一些特殊的应用当中我们就必须要考虑这个差异。

​	例如：

​	想在D线程上用ddx还原C的值：我在D处进行了纹理采样，想要通过ddx还原C的准确值，那么如果直接执行D-ddx(D)得到的结果可能是：D- B+A，这是对C的估计值而并非C的准确值。

​	**所以，ddx并不能用来节省纹理采样，因为结果依赖具体的图形接口。**

## **Partial Derivatives** 与if语句

​	在使用if语句的时候使用导数功能同样要特别注意！

​	导数计算是基于一个着色器的多个实例在GPU硬件上的并行执行。

​	**标量操作通过SIMD(单指令多数据)架构在寄存器上执行，寄存器包含一个2×2像素块的4个值的向量。这意味着在执行的每一步，属于每个2×2块的着色器实例都是同步的，使得导数计算快速且易于在硬件中实现，只是简单地将包含在同一寄存器中的值进行减法。**

​	但是在条件分支的情况下会发生什么呢?在这种情况下，如果不是一个核心中的所有线程都采用同一个分支，**那么在代码执行中就会出现分歧**。**除了分支的效率和性能损失外，发散还破坏了块中像素之间的同步，使得导数操作无法定义。**

​	当涉及到纹理采样，问题又变得不同了（需要用到mipmap级别选择、各向异性滤波等方面的**导数**）。当遇到这样的问题时，着色器编译器可以平化分支(从而避免它)，或者尝试重新排列代码，将纹理读取移动到分支控制流之外。当采样纹理时，使用显式导数（这里的显示导数指的是SampleGrad，而非DDX、DDY）或mipmap级别可以避免这个问题。

还有其他的细节可以参考：[An introduction to shader derivative functions](http://www.aclockworkberry.com/shader-derivative-functions/)

